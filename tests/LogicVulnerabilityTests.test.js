/**
 * 逻辑漏洞和边界条件测试
 * @jest-environment jsdom
 * 
 * 专注于发现：
 * 1. 空指针解引用
 * 2. 数组越界访问
 * 3. 除零错误
 * 4. 无限循环风险
 * 5. 资源泄漏
 * 6. 竞态条件
 * 7. 状态不一致
 */

require('jest-canvas-mock');

describe('逻辑漏洞和边界条件测试', () => {
    let gameController;
    let canvas;

    beforeEach(() => {
        canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        
        const GameController = require('../src/core/GameController.js');
        gameController = new GameController(canvas);
    });

    afterEach(() => {
        if (gameController && gameController.stop) {
            gameController.stop();
        }
    });

    // ==================== 空指针/未定义值测试 ====================
    describe('空指针和未定义值处理', () => {
        test('null玩家对象应该被安全处理', () => {
            gameController.start();
            gameController.gameState.player = null;
            
            expect(() => {
                gameController.updatePlayer(0.016);
                gameController.renderPlayer();
            }).not.toThrow();
        });

        test('undefined龙对象应该被跳过', () => {
            gameController.start();
            gameController.gameState.dragons = [undefined, null, { type: 'stone', x: 100, y: 100 }];
            
            expect(() => {
                gameController.updateDragons(0.016);
            }).not.toThrow();
        });

        test('空数组操作应该安全', () => {
            gameController.gameState.bullets = [];
            gameController.gameState.dragons = [];
            gameController.gameState.particles = [];
            
            expect(() => {
                gameController.update(0.016);
                gameController.render();
            }).not.toThrow();
        });

        test('缺失属性应该使用默认值', () => {
            gameController.start();
            const dragon = gameController.gameState.dragons[0];
            
            delete dragon.speed;
            delete dragon.damage;
            
            expect(() => {
                gameController.updateDragon(dragon, 0.016);
            }).not.toThrow();
        });

        test('空技能配置应该被处理', () => {
            gameController.start();
            
            expect(() => {
                gameController.skillSystem.useSkill(null);
                gameController.skillSystem.useSkill(undefined);
                gameController.skillSystem.useSkill('');
            }).not.toThrow();
        });

        test('空元素类型应该回退到normal', () => {
            const element = gameController.elementSystem.getElement(null);
            expect(element).toBeDefined();
            
            const element2 = gameController.elementSystem.getElement(undefined);
            expect(element2).toBeDefined();
        });
    });

    // ==================== 数组边界测试 ====================
    describe('数组边界和索引安全', () => {
        test('负数索引不应该导致错误', () => {
            gameController.start();
            
            expect(() => {
                const bullet = gameController.gameState.bullets[-1];
                const dragon = gameController.gameState.dragons[-5];
            }).not.toThrow();
        });

        test('超大索引不应该导致错误', () => {
            gameController.start();
            
            expect(() => {
                const bullet = gameController.gameState.bullets[999999];
                const dragon = gameController.gameState.dragons[999999];
            }).not.toThrow();
        });

        test('splice操作应该检查索引', () => {
            gameController.start();
            const initialLength = gameController.gameState.bullets.length;
            
            expect(() => {
                gameController.gameState.bullets.splice(-1, 1);
                gameController.gameState.bullets.splice(999, 1);
            }).not.toThrow();
        });

        test('遍历时删除元素应该安全', () => {
            gameController.start();
            
            // 添加多个子弹
            for (let i = 0; i < 10; i++) {
                gameController.handlePlayerShoot();
            }
            
            expect(() => {
                // 模拟遍历删除
                for (let i = gameController.gameState.bullets.length - 1; i >= 0; i--) {
                    if (i % 2 === 0) {
                        gameController.gameState.bullets.splice(i, 1);
                    }
                }
            }).not.toThrow();
        });

        test('push到已满数组应该被限制', () => {
            gameController.start();
            
            // 尝试添加大量对象
            for (let i = 0; i < 100000; i++) {
                gameController.gameState.particles.push({
                    x: 0, y: 0, lifetime: 1000
                });
            }
            
            // 应该有清理机制
            gameController.cleanupParticles();
            expect(gameController.gameState.particles.length).toBeLessThan(50000);
        });
    });

    // ==================== 数学运算测试 ====================
    describe('数学运算和除零保护', () => {
        test('除零应该被处理', () => {
            expect(() => {
                const result = gameController.calculateDamage(100, 0);
                expect(isFinite(result)).toBe(true);
            }).not.toThrow();
        });

        test('NaN应该被检测', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            
            player.x = NaN;
            player.y = NaN;
            
            gameController.validatePlayerPosition();
            
            expect(isNaN(player.x)).toBe(false);
            expect(isNaN(player.y)).toBe(false);
        });

        test('Infinity应该被限制', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            
            player.speed = Infinity;
            player.damage = -Infinity;
            
            gameController.validatePlayerStats();
            
            expect(isFinite(player.speed)).toBe(true);
            expect(isFinite(player.damage)).toBe(true);
        });

        test('负数速度应该被修正', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            
            player.speed = -100;
            gameController.validatePlayerStats();
            
            expect(player.speed).toBeGreaterThanOrEqual(0);
        });

        test('负数生命值应该为0', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            
            player.health = -50;
            gameController.validatePlayerHealth();
            
            expect(player.health).toBe(0);
        });

        test('距离计算应该处理重叠点', () => {
            const dx = 0;
            const dy = 0;
            const distance = Math.hypot(dx, dy);
            
            expect(() => {
                const normalized = dx / distance;
            }).not.toThrow();
        });

        test('角度计算应该在有效范围', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            const dragon = { x: player.x, y: player.y };
            
            expect(() => {
                const angle = Math.atan2(dragon.y - player.y, dragon.x - player.x);
                expect(isFinite(angle)).toBe(true);
            }).not.toThrow();
        });
    });

    // ==================== 循环和递归测试 ====================
    describe('循环和递归安全', () => {
        test('龙身体更新不应该无限循环', () => {
            gameController.start();
            const dragon = gameController.gameState.dragons[0];
            
            // 创建异常长的身体
            dragon.bodySegments = Array(1000).fill().map((_, i) => ({
                id: `seg-${i}`,
                x: 400,
                y: 300,
                radius: 10
            }));
            
            const start = Date.now();
            gameController.updateDragonBodySegments(dragon, 0.016);
            const duration = Date.now() - start;
            
            // 应该在合理时间完成
            expect(duration).toBeLessThan(100);
        });

        test('路径追踪不应该陷入死循环', () => {
            gameController.start();
            const dragon = gameController.gameState.dragons[0];
            
            // 创建循环路径
            dragon.bodyPath = [
                { x: 100, y: 100 },
                { x: 200, y: 100 },
                { x: 200, y: 200 },
                { x: 100, y: 200 }
            ];
            
            expect(() => {
                const start = Date.now();
                gameController.trimDragonBodyPath(dragon, 20);
                const duration = Date.now() - start;
                expect(duration).toBeLessThan(50);
            }).not.toThrow();
        });

        test('事件冒泡不应该无限递归', () => {
            gameController.start();
            
            let eventCount = 0;
            gameController.eventSystem.on('TEST_EVENT', () => {
                eventCount++;
                if (eventCount < 10) {
                    gameController.eventSystem.emit('TEST_EVENT');
                }
            });
            
            gameController.eventSystem.emit('TEST_EVENT');
            
            // 应该能正常结束
            expect(eventCount).toBeLessThan(20);
        });

        test('碰撞检测不应该O(n^2)失控', () => {
            gameController.start();
            
            // 创建大量实体
            for (let i = 0; i < 100; i++) {
                gameController.gameState.bullets.push({
                    x: Math.random() * 800,
                    y: Math.random() * 600,
                    radius: 5
                });
            }
            
            const start = Date.now();
            gameController.checkCollisions();
            const duration = Date.now() - start;
            
            // 100个对象碰撞检测应该很快
            expect(duration).toBeLessThan(50);
        });
    });

    // ==================== 状态一致性测试 ====================
    describe('状态一致性和完整性', () => {
        test('游戏结束后不应该继续更新', () => {
            gameController.start();
            gameController.gameState.gameOver = true;
            
            const wave = gameController.gameState.wave;
            gameController.update(0.016);
            
            // 游戏结束后波次不应该变化
            expect(gameController.gameState.wave).toBe(wave);
        });

        test('暂停时不应该更新游戏逻辑', () => {
            gameController.start();
            gameController.pause();
            
            const player = gameController.gameState.getPlayer();
            const initialX = player.x;
            
            gameController.keys = { w: true };
            gameController.update(0.016);
            
            // 暂停时玩家不应该移动
            expect(player.x).toBe(initialX);
        });

        test('玩家死亡后应该触发游戏结束', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            
            gameController.damagePlayer(player.health);
            
            expect(player.health).toBe(0);
            expect(gameController.gameState.gameOver).toBe(true);
        });

        test('波次完成后应该生成新敌人', () => {
            gameController.start();
            
            // 清空所有龙
            gameController.gameState.dragons = [];
            
            gameController.nextWave();
            
            // 应该有新的龙
            expect(gameController.gameState.dragons.length).toBeGreaterThan(0);
        });

        test('资源消耗应该正确扣除', () => {
            gameController.start();
            gameController.gameState.resources.gold = 100;
            
            const cost = 50;
            gameController.spendGold(cost);
            
            expect(gameController.gameState.resources.gold).toBe(50);
        });

        test('资源不足时不应该允许消费', () => {
            gameController.start();
            gameController.gameState.resources.gold = 10;
            
            const result = gameController.canAfford(100);
            expect(result).toBe(false);
        });

        test('经验值应该正确累积', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            const initialExp = player.experience;
            
            gameController.addExperience(50);
            
            expect(player.experience).toBe(initialExp + 50);
        });

        test('升级应该重置经验条', () => {
            gameController.start();
            const player = gameController.gameState.getPlayer();
            
            player.experience = player.experienceToNext;
            gameController.checkLevelUp();
            
            expect(player.experience).toBeLessThan(player.experienceToNext);
        });
    });

    // ==================== 并发和时序测试 ====================
    describe('并发和时序问题', () => {
        test('快速连续操作不应该导致状态错误', () => {
            gameController.start();
            
            expect(() => {
                for (let i = 0; i < 100; i++) {
                    gameController.handlePlayerShoot();
                }
            }).not.toThrow();
        });

        test('多次启动不应该创建重复资源', () => {
            const initialListeners = Object.keys(gameController.eventSystem.listeners).length;
            
            gameController.start();
            gameController.start();
            gameController.start();
            
            const finalListeners = Object.keys(gameController.eventSystem.listeners).length;
            
            // 监听器数量不应该成倍增长
            expect(finalListeners).toBeLessThan(initialListeners * 3);
        });

        test('重置应该清理所有状态', () => {
            gameController.start();
            
            // 添加各种状态
            gameController.gameState.score = 1000;
            gameController.gameState.wave = 10;
            gameController.skillSystem.cooldowns['volley'] = 5000;
            
            gameController.reset();
            
            expect(gameController.gameState.score).toBe(0);
            expect(gameController.gameState.wave).toBe(1);
            expect(gameController.skillSystem.cooldowns['volley']).toBeUndefined();
        });

        test('事件处理顺序应该正确', () => {
            const events = [];
            
            gameController.eventSystem.on('EVENT_A', () => events.push('A'));
            gameController.eventSystem.on('EVENT_B', () => events.push('B'));
            gameController.eventSystem.on('EVENT_C', () => events.push('C'));
            
            gameController.eventSystem.emit('EVENT_A');
            gameController.eventSystem.emit('EVENT_B');
            gameController.eventSystem.emit('EVENT_C');
            
            expect(events).toEqual(['A', 'B', 'C']);
        });
    });

    // ==================== 内存泄漏测试 ====================
    describe('内存泄漏检测', () => {
        test('停止游戏应该清理定时器', () => {
            gameController.start();
            const loopId = gameController.gameLoopId;
            
            gameController.stop();
            
            expect(gameController.gameLoopId).toBeNull();
        });

        test('大量粒子应该被自动清理', () => {
            gameController.start();
            
            for (let i = 0; i < 10000; i++) {
                gameController.gameState.particles.push({
                    x: 400,
                    y: 300,
                    vx: 1,
                    vy: 1,
                    lifetime: 0.001 // 极短寿命
                });
            }
            
            gameController.update(0.1);
            
            // 过期粒子应该被清理
            expect(gameController.gameState.particles.length).toBeLessThan(5000);
        });

        test('离屏子弹应该被清理', () => {
            gameController.start();
            
            // 创建离屏子弹
            for (let i = 0; i < 100; i++) {
                gameController.gameState.bullets.push({
                    x: -1000 - i * 10,
                    y: -1000 - i * 10,
                    vx: -1,
                    vy: -1,
                    radius: 5
                });
            }
            
            gameController.cleanupOffscreenEntities();
            
            expect(gameController.gameState.bullets.length).toBeLessThan(50);
        });

        test('移除的龙应该清理所有引用', () => {
            gameController.start();
            const dragon = gameController.gameState.dragons[0];
            const dragonId = dragon.id;
            
            gameController.damageDragon(dragon, dragon.health);
            
            // 龙应该从数组中移除
            const stillExists = gameController.gameState.dragons.some(d => d.id === dragonId);
            expect(stillExists).toBe(false);
        });

        test('事件监听器应该能取消', () => {
            const handler = jest.fn();
            gameController.eventSystem.on('TEST_EVENT', handler);
            
            gameController.eventSystem.off('TEST_EVENT', handler);
            gameController.eventSystem.emit('TEST_EVENT');
            
            expect(handler).not.toHaveBeenCalled();
        });
    });

    // ==================== 输入验证测试 ====================
    describe('输入验证和边界值', () => {
        test('非法技能等级应该被拒绝', () => {
            gameController.start();
            
            expect(() => {
                gameController.skillSystem.upgradeSkill('volley', -1);
                gameController.skillSystem.upgradeSkill('volley', 999);
            }).not.toThrow();
        });

        test('非法难度应该使用默认值', () => {
            const EndlessMode = require('../src/modes/EndlessMode.js');
            const endlessMode = new EndlessMode(gameController);
            
            const result = endlessMode.start('invalid_difficulty');
            expect(result).toBe(false);
        });

        test('空字符串元素应该被处理', () => {
            const element = gameController.elementSystem.getElement('');
            expect(element).toBeDefined();
        });

        test('特殊字符技能名应该被拒绝', () => {
            const result = gameController.skillSystem.useSkill('../../etc/passwd');
            expect(result).toBeFalsy();
        });

        test('超长数组应该被截断', () => {
            gameController.start();
            
            // 创建超长路径
            const dragon = gameController.gameState.dragons[0];
            dragon.bodyPath = Array(10000).fill({ x: 100, y: 100 });
            
            gameController.trimDragonBodyPath(dragon, 20);
            
            expect(dragon.bodyPath.length).toBeLessThan(1000);
        });
    });

    // ==================== 配置加载测试 ====================
    describe('配置加载和回退', () => {
        test('缺失的BalanceConfig应该使用默认值', () => {
            expect(() => {
                const config = gameController.balanceConfig;
                expect(config).toBeDefined();
            }).not.toThrow();
        });

        test('损坏的配置数据应该被忽略', () => {
            expect(() => {
                const saved = '{"wave": "not a number"}';
                gameController.loadGameState(saved);
            }).not.toThrow();
        });

        test('空配置对象应该使用默认值', () => {
            const GameController = require('../src/core/GameController.js');
            const controller = new GameController(canvas, {});
            
            expect(controller.width).toBe(800);
            expect(controller.height).toBe(600);
        });
    });
});


<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¾™æ®µç³»ç»Ÿæµ‹è¯•</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
            font-family: 'Courier New', monospace;
        }
        #gameCanvas {
            border: 2px solid #4a90e2;
            display: block;
            margin: 20px auto;
            background: #0f0f1e;
        }
        .info-panel {
            max-width: 800px;
            margin: 0 auto;
            padding: 15px;
            background: #16213e;
            border-radius: 8px;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px;
            background: #0f3460;
            border-radius: 4px;
        }
        .segment-list {
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        .segment-item {
            padding: 6px;
            margin: 4px 0;
            background: #1a1a2e;
            border-left: 3px solid #4a90e2;
            font-size: 12px;
        }
        .segment-item.damaged {
            border-left-color: #ff6b6b;
        }
        button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #357abd;
        }
    </style>
</head>
<body>
    <div class="info-panel">
        <h2>ğŸ‰ é¾™æ®µç³»ç»Ÿæµ‹è¯•</h2>
        <div>
            <button onclick="spawnTestDragon()">ç”Ÿæˆæµ‹è¯•é¾™</button>
            <button onclick="damageRandomSegment()">éšæœºä¼¤å®³ä¸€ä¸ªæ®µ</button>
            <button onclick="clearDragons()">æ¸…é™¤æ‰€æœ‰é¾™</button>
        </div>
        <div class="stat-row">
            <span>é¾™æ•°é‡:</span>
            <span id="dragonCount">0</span>
        </div>
        <div class="stat-row">
            <span>å½“å‰æ³¢æ¬¡:</span>
            <span id="currentWave">1</span>
        </div>
        <div id="segmentList" class="segment-list"></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script type="module">
        import BalanceConfig from './src/config/BalanceConfig.js';
        import GameState from './src/core/GameState.js';
        import GameController from './src/core/GameController.js';

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const gameState = new GameState();
        const gameController = new GameController(canvas.width, canvas.height, gameState);

        let dragons = [];
        let lastTime = performance.now();

        // ç”Ÿæˆæµ‹è¯•é¾™
        window.spawnTestDragon = function() {
            const wave = gameState.getWave();
            const stats = BalanceConfig.getEnemyStats(wave, 'dragon');
            
            const dragon = {
                id: `test-dragon-${Date.now()}`,
                type: 'dragon',
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                vx: (Math.random() - 0.5) * 60,
                vy: (Math.random() - 0.5) * 60,
                radius: 24,
                health: stats.health,
                maxHealth: stats.health,
                damage: stats.damage,
                speed: stats.speed,
                reward: stats.reward,
                color: '#ff6b6b',
                glowColor: '#ff4444',
                bodySegments: []
            };

            gameController.setupDragonBodySegments(dragon);
            dragons.push(dragon);
            updateUI();
        };

        // éšæœºä¼¤å®³ä¸€ä¸ªæ®µ
        window.damageRandomSegment = function() {
            if (dragons.length === 0) return;
            
            const dragon = dragons[Math.floor(Math.random() * dragons.length)];
            if (!dragon.bodySegments || dragon.bodySegments.length === 0) return;
            
            const segment = dragon.bodySegments[Math.floor(Math.random() * dragon.bodySegments.length)];
            const damage = 20;
            segment.health = Math.max(0, segment.health - damage);
            segment.hitFlash = 1.0;
            
            console.log(`ä¼¤å®³æ®µ ${segment.segmentIndex}: ${segment.health}/${segment.maxHealth}`);
            
            // æ£€æŸ¥æ®µæ˜¯å¦è¢«æ‘§æ¯
            if (segment.health <= 0) {
                const index = dragon.bodySegments.indexOf(segment);
                if (index > -1) {
                    dragon.bodySegments.splice(index, 1);
                    console.log(`æ®µå·²æ‘§æ¯! å‰©ä½™ ${dragon.bodySegments.length} æ®µ`);
                }
            }
            
            updateUI();
        };

        // æ¸…é™¤æ‰€æœ‰é¾™
        window.clearDragons = function() {
            dragons = [];
            updateUI();
        };

        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('dragonCount').textContent = dragons.length;
            document.getElementById('currentWave').textContent = gameState.getWave();
            
            const segmentList = document.getElementById('segmentList');
            segmentList.innerHTML = '';
            
            dragons.forEach((dragon, dragonIndex) => {
                const dragonHeader = document.createElement('div');
                dragonHeader.className = 'segment-item';
                dragonHeader.style.background = '#2a4858';
                dragonHeader.innerHTML = `<strong>é¾™ #${dragonIndex + 1}</strong> - æ®µæ•°: ${dragon.bodySegments?.length || 0} / ${dragon.targetSegmentCount || 0}`;
                segmentList.appendChild(dragonHeader);
                
                if (dragon.bodySegments) {
                    dragon.bodySegments.forEach((seg, idx) => {
                        const segItem = document.createElement('div');
                        segItem.className = 'segment-item';
                        if (seg.health < seg.maxHealth) {
                            segItem.classList.add('damaged');
                        }
                        const healthPercent = ((seg.health / seg.maxHealth) * 100).toFixed(0);
                        segItem.innerHTML = `æ®µ ${idx}: HP ${seg.health.toFixed(0)}/${seg.maxHealth.toFixed(0)} (${healthPercent}%)`;
                        segmentList.appendChild(segItem);
                    });
                }
            });
        }

        // æ¸²æŸ“å¾ªç¯
        function render() {
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ¸²æŸ“æ¯æ¡é¾™
            dragons.forEach(dragon => {
                // æ¸²æŸ“èº«ä½“æ®µ
                if (dragon.bodySegments) {
                    dragon.bodySegments.forEach((seg, idx) => {
                        ctx.save();
                        
                        // ç»˜åˆ¶æ®µ
                        ctx.beginPath();
                        ctx.arc(seg.x, seg.y, seg.radius, 0, Math.PI * 2);
                        
                        // å¥åº·åº¦é¢œè‰²
                        const healthRatio = seg.health / seg.maxHealth;
                        const r = 255;
                        const g = Math.floor(100 + healthRatio * 100);
                        const b = Math.floor(100 + healthRatio * 100);
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fill();
                        
                        // å‡»ä¸­é—ªçƒ
                        if (seg.hitFlash > 0) {
                            ctx.strokeStyle = `rgba(255, 255, 255, ${seg.hitFlash})`;
                            ctx.lineWidth = 3;
                            ctx.stroke();
                        }
                        
                        // è¾¹æ¡†
                        ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // æ®µç¼–å·
                        ctx.fillStyle = 'white';
                        ctx.font = '10px monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(idx, seg.x, seg.y);
                        
                        ctx.restore();
                    });
                }
                
                // æ¸²æŸ“å¤´éƒ¨
                ctx.save();
                ctx.beginPath();
                ctx.arc(dragon.x, dragon.y, dragon.radius, 0, Math.PI * 2);
                ctx.fillStyle = dragon.color;
                ctx.fill();
                ctx.strokeStyle = dragon.glowColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // å¤´éƒ¨æ ‡è®°
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('HEAD', dragon.x, dragon.y);
                
                ctx.restore();
            });
        }

        // æ›´æ–°å¾ªç¯
        function update() {
            const now = performance.now();
            const deltaTime = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            
            dragons.forEach(dragon => {
                // æ›´æ–°ä½ç½®
                dragon.x += dragon.vx * deltaTime;
                dragon.y += dragon.vy * deltaTime;
                
                // è¾¹ç•Œåå¼¹
                if (dragon.x < dragon.radius || dragon.x > canvas.width - dragon.radius) {
                    dragon.vx *= -1;
                    dragon.x = Math.max(dragon.radius, Math.min(canvas.width - dragon.radius, dragon.x));
                }
                if (dragon.y < dragon.radius || dragon.y > canvas.height - dragon.radius) {
                    dragon.vy *= -1;
                    dragon.y = Math.max(dragon.radius, Math.min(canvas.height - dragon.radius, dragon.y));
                }
                
                // æ›´æ–°é¾™æ®µ
                gameController.updateDragonBodySegments(dragon, deltaTime);
            });
            
            render();
            requestAnimationFrame(update);
        }

        // å¯åŠ¨
        updateUI();
        update();
        
        console.log('é¾™æ®µç³»ç»Ÿæµ‹è¯•å·²å¯åŠ¨!');
        console.log('- ç‚¹å‡»"ç”Ÿæˆæµ‹è¯•é¾™"åˆ›å»ºé¾™');
        console.log('- ç‚¹å‡»"éšæœºä¼¤å®³ä¸€ä¸ªæ®µ"æµ‹è¯•æ®µä¼¤å®³');
        console.log('- è§‚å¯Ÿæ®µçš„ç”Ÿé•¿è¿‡ç¨‹ï¼ˆæ¯4.5ç§’ä¸€ä¸ªæ–°æ®µï¼‰');
    </script>
</body>
</html>

